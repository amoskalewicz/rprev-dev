---
title: "Testing Weibull Model"
author: "Stuart Lacy"
date: "26 April 2016"
output: 
  html_document: 
    number_sections: yes
    theme: lumen
    toc: yes
    toc_float:
        collapsed: false
    code_folding: show
---

# Introduction

The aim of this script is to better understand the Weibull parameterisation, and how survival probabilities are extracted from it directly using `pweibull`, as is done during the `prevalence` function. I'd like to verify for my own understanding that these survival probabilities are consistent with those generated from `survreg`, and how to obtain them without having to manually calculate it from `pweibull`.

# Setup

```{r, message=F, warning=F}
library(dplyr)
library(abind)
library(rms)
library(survival)
library(devtools)
library(knitr)
opts_chunk$set(message=F, warning=F, error=T)
```

Let's firstly build a survival model using this data just as is done during the bootstrapping part of `prevalence`, with age and sex as the two covariates.

```{r}
registry_data <- readRDS("../data/registry_data.rds")
mod <- survreg(Surv(stime, status) ~ sex + age, data=registry_data, dist='weibull')
mod
```

**NB: That what is called `scale` in the `survreg` object is actually 1 / shape of `pweibull`, and the `scale` from `pweibull` is equal to exp(betaX) in `survreg`**

```{r}
coefs <- mod$coefficients
scale <- mod$scale
```

# Analysis

In the bootstrapping code, the survival probability is extracted using `pweibull`, rather than using any of the `survival` package's functions. This is more computationally efficient, however, it requires dealing with the difference in parameterisation of `scale` and `shape` between `survival` and `pweibull`.

In this example I'm going to predict the survival probability for a 60 year old man at 500 days.

```{r}
pred_st = 1 - pweibull(500, scale=exp(coefs[1] + 0 * coefs[2] + 60 * coefs[3]), shape=1/scale)
pred_st
```

That's a pretty high survival probability!

Unfortunately, there isn't a simple method in survreg for calculating this probability, so how is it done otherwise? For Cox models and Kaplan-Meier estimates there are `survfit` methods to estimate survival probability, but none available for `survreg` objects. Furthermore, `predict.survreg` allows you to predict on the linear predictor scale, or on the quantile scale, but not as a probability. Since the `survreg` object is an AFT implementation rather than a PH one, it seems that it's easier to predict the event time rather than survival probability. We can therefore calculate the quantile associated with the known survival probability (well, *known* assuming that the `pweibull` calculation is correct), and check that this matches with the input value for time.

**NB: When using predict, we're predicting on the original scale (i.e. F(t), so ensure that I transform the output again)**

```{r}
predict(mod, newdata=list(age=60, sex=0), type='quantile', p=1-pred_st)
```

This produces the same number of days as Simon's method so that's a relief, however, it still doesn't answer how one would go about predicting survival probabilities at a given time, unless one runs the above `predict` function over a very fine range of probabilities and then use the closest time to the one of interest to estimate survival probability. However, this isn't very elegant and it is frustrating that there isn't a simple interface as it would save the headache of converting between two parameterisations.

# Using `flexsurv`

```{r}
library(flexsurv)
```

Let's try using the `flexsurv` package, which claims to provide more flexible options for parametric survival models and with more sane design choices.

```{r}
modflex <- flexsurvreg(Surv(stime, status) ~ sex + age, data=registry_data, dist='weibull')
```

This should make the exact same model as before, as under the hood it actually calls `survreg`, but the output object converts the parameters into the manner used by `pweibull`. Look at the nice clean `scale` and `shape` values! **NB: Since scale is a function of covariates, what is this value estimated here?**

```{r}
modflex
```

We can plot the survival curve for a 60 year old male, note that the model has a far different estimate to the Kaplan-Meier.

```{r}
plot(modflex, newdata=list(age=60, sex=0))
```

`summary.flexsurvreg` provides a direct calculation of these probabilities.

We can find the survival probability at t=500, happily this is exactly that returned by Simon's manual method.

```{r}
summary(modflex, newdata=list(age=60, sex=0), t=500)
```

Let's also extract the survival probability using the coefficients obtained from the `flexsurv` model.

**NB: These coefficients as displayed in the `print.flexsurvreg` method are exponentiated values of the estimates, when obtaining the estimates through `object$coefficients` it returns the log of these.**

```{r}
modflex
modflex$coefficients
```

## Scale

Note that the scale returned by `coefficients` is the exponent of that listed in the summary, and the exponent version is equal to the *intercept* from `survreg`.

Remember:

  `mod`: `survreg` model
  `modflex`: `flexsurvreg` model

```{r}
modflex$coefficients['scale']
exp(modflex$coefficients['scale'])
mod$coefficients[1]
```

## Shape

Again notice that the shape as reported in the summary is the log of that returned by the `coefficients` method, which is equal to the reciprocal of `survreg`'s scale. 

```{r}
modflex$coefficients['shape']
1 / exp(modflex$coefficients['shape'])
mod$scale
```

## Calculating survival probability

We're still using the parameterisation of including covariates whereby the `scale` we pass to the `pweibull` function is a function of `exp(scale + betaX)`.

Yes, it isn't necessary to include the sex value in the following call, however I've left it in for completeness sake.

```{r}
1 - pweibull(500, scale=exp(modflex$coefficients['scale'] + modflex$coefficients['age']*60 + modflex$coefficients['sex']*0), 
             shape=exp(modflex$coefficients['shape']))
```

Hooray, this produces the same accuracy as before. So note that if you're using `flexsurv` then the values of shape and scale displayed in the summary are those you'd use in practice, although the ones returned from the `coefficients` attribute need exponentiating first.

# Conclusions

The main conclusion from this is that `flexsurv` offers a more sane approach for working with parametric models, both in its consistent parameterisation with `pweibull`, and the added flexibility it provides. For instance, ancilliary paramters (those which aren't the location/scale one) can be formed as functions of the covariates, whereas in `survreg` only scale is allowed. Furthermore, there is a greater range of distributions on offer in `flexsurv`, including those with more than two parameters, in addition to providing an interface to implement custom distributions.

However, `flexsurv` isn't perfect, as the coefficients obtained from the `$coefficients` attribute are the log transforms of those listed in the summary, while the ones listed in the summary are those you'd use in `pweibull` calls. This can be confusing itself. It makes sense for `scale` to be returned on the log scale, as it's going to be exponentiated later on when calculating the linear predictor, but `shape` being returned from `$coefficients` on the log scale adds an extra step for the user. However, overall, this is less confusing than `survreg`'s parameterisation of shape as 1/scale, and scale as the intercept.

Therefore I'm going to use `flexsurv` for when I need to use parametric models, and also play around with its implementation of Royston's flexible parametric survival models, which use cubic splines in their base hazard function.