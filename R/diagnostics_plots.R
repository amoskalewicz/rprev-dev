#' Generate smoothed cumulative incidence function, inspect deviations in the registry data 
#' and compare with the cumulative incidence for constant diagnosis rate.
#'
#' The plot generated by the example shows the cumulative number of diagnoses in the registry 
#' by day in black. This is compared to the red line, which indicates what cumulative diagnosis 
#' would look like if the rate of diagnosis was constant. The green line is a smooth fitted to 
#' the actual cumulative diagnosis data. 
#' 
#' @param entry Vector of diagnosis dates for each patient in the registry.
#' @param start Date from which incident cases are included.
#' @param num_years Integer representing the number of complete years of the registry for which incidence is to be calculated.
#' @param df Integer representing degrees of freedom for the smoothening function.
#' @return Object containing incidence for each year of the registry, the cumulative incidence functions and corresponding deviations.
#' @examples
#' c_inc <- cumulative_incidence(registry_data$entrydate, start = "2004-01-30", num_years = 9)
#' ordered_diagnoses <- c_inc$ordered_diagnoses
#' cum_inc <- c_inc$cumulative_incidence
#' smooth <- c_inc$smooth
#' 
#' plot(ordered_diagnoses, cum_inc, pch=20, 
#' cex=0.7, xlab="days", ylab="cumulative diagnoses")
#' 
#' abline(a=0, b=length(ordered_diagnoses)/ordered_diagnoses[length(ordered_diagnoses)], 
#' col="red", lwd=2)
#' 
#' lines(smooth, col="green", lwd=2)
#' 
#' # The following plot shows the deviation of the raw data from the fitted smooth by day:
#' plot(ordered_diagnoses, cum_inc - predict(smooth, ordered_diagnoses)$y, 
#' type="l", xlab="days", ylab="deviation from smooth")
cumulative_incidence <- function(entry, start = NULL, num_years = NULL, df=6){
    
    if (is.null(start))
        start <- min(entry)
    
    if (is.null(num_years)) 
        num_years <- floor(as.numeric(difftime(max(entry), start) / 365.25))
    
    # Slightly confused that the following are not all integers:
    diags <- sort(as.numeric(difftime(entry, min(entry), units='days')))
    cum_inc <- seq(length(diags))
    smo <- smooth.spline(diags, cum_inc, df=df)
    
    cumulative_inc_out <- list(raw_incidence = incidence(entry, start, num_years),
                                ordered_diagnoses = diags, 
                                cumulative_incidence = cum_inc,
                                smooth = smo)
    attr(cumulative_inc_out, 'class') <- 'incidence'
    cumulative_inc_out
}    
    
#' Inspect incidence rate.
#' 
#' This function generates a plot from the incidence object. The incidence rate per year of the 
#' registry is shown in red. Mean incidence rate is shown as a dashed black line, with the 
#' 95\% confidence interval shown with dashed blue lines. The smooth fitted to the cumulative 
#' incidence data is shown in green.   
#' @param object Incidence object generated by cumulative_incidence().
#' @param level Double representing the desired confidence interval width.
#' @return Plot of incidence rate, confidence interval and smoothed incidence function.
#' inspect_incidence(c_inc)
inspect_incidence <- function(object, level=0.95){

    raw_incidence <- object$raw_incidence
    mean_rate <- mean(raw_incidence)
    day_mean_rate <- mean_rate/365
    
    z_conf <- qnorm((1+level)/2)
    CI_lim <- z_conf * sqrt(mean_rate)/365
    pl_lim <- CI_lim * 2.0
    num_years <- length(raw_incidence)

    plot(365*(1:num_years) - 182.5, raw_incidence/365, pch=20, col="red",
         xlab="days", ylab="incidence rate",
         ylim=c(day_mean_rate-pl_lim, day_mean_rate+pl_lim ))
    lines(365*(1:num_years) - 182.5, raw_incidence/365, col="red",lwd=2)
    lines(predict(c_inc$smooth, 1:(365*num_years), deriv=1), type="l", lwd=2, col="green")
    
    abline(h = day_mean_rate, lty=2)
    abline(h = day_mean_rate - CI_lim, lty=3, col="blue")
    abline(h = day_mean_rate + CI_lim, lty=3, col="blue")
    abline(v=(1:num_years)*365, col="pink", lty=2)
    
}

#' Inspect consistency of incidence rate with an homogeneous Poisson process using simulation.
#' 
#' This function generates a plot where the red line is the deviation of cumulative diagnoses 
#' from the fitted smooth taken from the incidence object. In order to ascertain if the deviation 
#' is within reasonable bounds, simulation is used. The grey lines represent N draws from a 
#' uniform distribution between 0 and the last day of diagnosis, where N is the number of incident 
#' cases, plotted as deviations from a smooth fitted to them. The blue lines are 95\% confidence
#' intervals drawn from the simulated data.
#'
#' @param object Incidence object generated by cumulative_incidence().
#' @param N_sim Number of draws from a homogeneous Poisson process.
#' @param level Double representing the desired confidence interval width.
#' @param df Integer representing degrees of freedom for the smoothening function.
#' @return Plots of the smoothed incidence function and corresponding deviations.
#' @examples
#' poisson_incidence_sim(c_inc)
poisson_incidence_sim <- function(object, N_sim=1000, level=0.95, df=4){

  diags <- object$ordered_diagnoses
  N <- length(diags)
  boot_out <- matrix(NA, nrow = N_sim, ncol = N)

  set.seed(17)
  for (i in 1:N_sim){
    x <- sort(runif(N, 0, max(diags)))
    the_smo <- smooth.spline(x, 1:N, df=df)
    boot_out[i, ] <- (1:N) - predict(the_smo, x)$y
  }
  
  plot(NA, xlim=c(0, max(diags)), ylim=c(-0.8*max(boot_out),0.8*max(boot_out)), xlab="days", ylab="deviation from smooth")
  sapply(seq(N_sim),
         function(i) lines(x, boot_out[i,], col="grey")) 

  lines(diags, object$cumulative_incidence - predict(object$smooth, diags)$y, col="red")
  lines(x, apply(boot_out, 2, quantile, probs=(1+level)/2), col="blue")
  lines(x, apply(boot_out, 2, quantile, probs=1-((1+level)/2)), col="blue")

}

#' Inspect consistency of survival data between years of the registry and with a Cox Proportional Hazards model.
#'
#' The first plot is of the Kaplan-Meier survival curve on total cases in the registry. The second plot is the
#' Kaplan-Meier survival curve for each age group, as delineated by the user using the "ages" argument. The third
#' plot is of the residuals between the raw data and the fitted Cox Proportional Hazards model. If the model is
#' a good representation of the data the line should be horizontal. The last plot is of Kaplain Meier survival
#' curves fitted to cases subdivided by year of diagnosis within the registry (black lines), compared to total
#' cases shown in blue.
#'
#' @param form
#' @param data A registry dataset of patient cases generated using load_data().
#' @param ages A vector of ages at which to break the dataset for Kaplan Meier plotting.
#' @param start Date from which incident cases are included.
#' @param num_years Integer representing the number of complete years of the registry for which incidence is to be calculated.
#' @return A sequence of plots indicated the consistency of survival data between years of the registry and with a Cox Proportional Hazards model.
#' @examples
#' survival_modelling_diagnostics(Surv(time, status) ~ age(age) + entry(entrydate), registry_data,
#' ages = c(55, 65, 75, 85, 100), start = "2004-09-01", num_years = 9)
survival_modelling_diagnostics <- function(form, data, ages, start = NULL, num_years = NULL){
    
    ### TO DO/discuss:
    # ?Too much duplicated code with prevalence() to extract variables from formula
    # Make generic to not just age cuts
    
    # Extract required column names from formula
    spec <- c('age', 'entry')
    terms <- terms(form, spec)
    special_indices <- attr(terms, 'specials')
    
    if (any(sapply(special_indices, is.null)))
        stop("Error: Provide function terms for age and entry date.")
    
    v <- as.list(attr(terms, 'variables'))[-1]
    var_names <- unlist(lapply(special_indices, function(i) v[i]))
    
    age_var <- .extract_var_name(var_names$age)
    entry_var <- .extract_var_name(var_names$entry)
    
    # Extract survival formula
    response_index <- attr(terms, 'response')
    resp <- v[response_index][[1]]
    non_covariate_inds <- c(response_index, unlist(special_indices))
    covar_names <- as.list(attr(terms, 'variables'))[-1][-non_covariate_inds]  # First -1 to remove 'list' entry
    
    if (length(covar_names) > 0)
        stop("Error: Functionality isn't currently provided for additional covariates.")
    
    # Determine the registry years of interest from assessing the code
    if (is.null(start))
        start <- min(data[, entry_var])
    
    if (is.null(num_years)) 
        num_years <- floor(as.numeric(difftime(max(data[, entry_var]), start) / 365.25))
    
    # Check ages input is correct
    if (is.numeric(ages) != TRUE) stop("Error: ages is not numeric.")
    if (is.vector(ages) != TRUE) stop("Error: ages is not a vector.")
    
    par(mfrow=c(2,2))
    
    # Plot KM overall
    data_r <- data[data[, entry_var] >= start, ]
    surv_form_1 <- as.formula(paste(deparse(resp), '~ 1'))
    km <- survfit(surv_form_1, data_r)
    plot(km, lwd=2, col="blue", xlab="survival (days)", ylab="probability")
    
    # Plot KM stratified by age
    plot(survfit(as.formula(paste(deparse(resp), '~ cut(', 
                                          age_var, ', breaks = ages)', sep='')), data_r), 
                 lwd=2, col=1:length(ages), xlab="survival (days)", ylab="probability")
    cx <- coxph(as.formula(paste(deparse(resp), '~ ', age_var, sep='')), data_r)
    cxp <- survfit(cx, 
                   newdata=data.frame(assign(age_var, 
                                             vapply(seq(length(ages) - 1), 
                                                    function(i) mean(c(ages[i], ages[i + 1])), 
                                                    numeric(1)))))
    lines(cxp, lwd=2, col=1:length(ages), lty=2, mark.time=F)
    
    # Plot coxph residuals
    plot(cox.zph(cx))
    
    # Plot KM stratified by year of diagnosis
    plot(km, lwd=2, col="blue", mark.time=F, conf.int=T, xlab="survival (days)", ylab="probability")
    registry_years <- .determine_registry_years(start, num_years)
    sapply(seq(num_years),
           function(i) lines(survfit(surv_form_1, 
                                     data=data[data[, entry_var] >= registry_years[i] & data[, entry_var] < registry_years[i + 1], ]), 
                             mark.time = F, conf.int = F)) 
    
    sapply(seq(num_years),
           function(i) length(data$entrydate[data[, entry_var] >= registry_years[i] & data[, entry_var] < registry_years[i + 1]]))
    
    # Output plots and test of proportionality assumption
    return(cox.zph(cx))
    
}

#' Inspect functional form of age.
#'
#' @param form 
#' @param data A registry dataset of patient cases.
#' @param df Degrees of freedom for the smooth.
#' @return Plots of the functional form of age.
#' @examples
#' functional_form_age(registry_data_r)
functional_form_age <- function(form, data, df=4){
  
  ### TO DO/discuss:
  # ?No reason why this can't be applied to any continuous covariate, just need to change age() and age_ prefixes
  # ?How to neaten up the output; control side effects, do we need both plots etc
  # ?Too much duplication of code here with prevalence()
  ###
    
  # Extract required column names from formula
  terms <- terms(form, 'age')
  special_indices <- attr(terms, 'specials')
    
  if (any(sapply(special_indices, is.null)))
    stop("Error: Provide function term for age.")
    
  v <- as.list(attr(terms, 'variables'))[-1]
  var_names <- unlist(lapply(special_indices, function(i) v[i]))
  age_var <- .extract_var_name(var_names$age)
    
  # Extract survival formula
  response_index <- attr(terms, 'response')
  resp <- v[response_index][[1]]
  
  psp_surv_form <- as.formula(paste(deparse(resp), '~ pspline(', 
                                    age_var, ', ', df, ')', sep=''))
  
  cxnl <- coxph(psp_surv_form, data)
  output1 <- summary(cxnl)

  plt1 <- termplot(cxnl)

  f <<- datadist(data)
  options(datadist="f")

  rcs_surv_form <- as.formula(paste(deparse(resp), '~ rcs(', 
                                    age_var, ', ', df, ')', sep=''))
  
  mod_rms <- cph(rcs_surv_form, data, x=TRUE, y=TRUE, surv=T, time.inc=1)
  output2 <- anova(mod_rms)
  output3 <- summary(mod_rms)
  
  plt2 <- plot(eval(parse(text=paste('Predict(mod_rms, ', age_var,')', sep = ''))), lwd=3, adj.subtitle=T)

  list(plt1, plt2, output1, output2, output3)

}