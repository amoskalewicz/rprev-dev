#' Generate smoothed cumulative incidence function, inspect deviations in the registry data 
#' and compare with the cumulative incidence for constant diagnosis rate.
#'
#' The plot generated by the example shows the cumulative number of diagnoses in the registry 
#' by day in black. This is compared to the red line, which indicates what cumulative diagnosis 
#' would look like if the rate of diagnosis was constant. The green line is a smooth fitted to 
#' the actual cumulative diagnosis data. 
#' 
#' @param entry Vector of diagnosis dates for each patient in the registry.
#' @param start Date from which incident cases are included.
#' @param num_years Integer representing the number of complete years of the registry for which incidence is to be calculated.
#' @param df Degrees of freedom for the smoothening function.
#' @return Plot of the cumulative incidence functions and corresponding deviations.
#' @examples
#' c_inc <- cumulative_incidence(registry_data$entrydate, start = "2004-01-30", num_years = 9)
#' ordered_diagnoses <- c_inc$ordered_diagnoses
#' 
#' plot(ordered_diagnoses, c_inc$cumulative_incidence, pch=20, 
#' cex=0.7, xlab="days", ylab="cumulative diagnoses")
#' 
#' abline(a=0, b=length(c_inc$ordered_diagnoses)/c_inc$ordered_diagnoses[length(c_inc$ordered_diagnoses)], 
#' col="red", lwd=2)
#' 
#' lines(c_inc$smooth, col="green", lwd=2)
cumulative_incidence <- function(entry, start = NULL, num_years = NULL, df=6){
    
    if (is.null(start))
        start <- min(entry)
    
    if (is.null(num_years)) 
        num_years <- floor(as.numeric(difftime(max(entry), start) / 365.25))
    
    # Slightly confused that the following are not all integers:
    diags <- sort(as.numeric(difftime(entry, min(entry), units='days')))
    cum_inc <- seq(length(diags))
    smo <- smooth.spline(diags, cum_inc, df=df)
    
    list(ordered_diagnoses = diags, 
         cumulative_incidence = cum_inc,
         smooth = smo)
}    
    
    
    
    raw_incidence <- incidence(entry, start, num_years)
    
    plot(diags, cum_inc - predict(smo, diags)$y, type="l", xlab="days", ylab="deviation from smooth")
    mean_rate <- mean(raw_incidence)
    day_mean_rate <- mean_rate/365
    CI_lim <- 1.96 * sqrt(mean_rate)/365
    pl_lim <- CI_lim * 2.0
    
    plot(365*(1:num_years) - 182.5, raw_incidence/365, pch=20, col="red",
         xlab="days", ylab="incidence rate",
         ylim=c(day_mean_rate-pl_lim, day_mean_rate+pl_lim ))
    lines(365*(1:num_years) - 182.5, raw_incidence/365, col="red",lwd=2)
    lines(predict(smo, 1:(365*num_years), deriv=1), type="l", lwd=2, col="green")
    
    abline(h = day_mean_rate, lty=2)
    abline(h = day_mean_rate - CI_lim, lty=3, col="blue")
    abline(h = day_mean_rate + CI_lim, lty=3, col="blue")
    abline(v=(1:num_years)*365, col="pink", lty=2)
    
    N <- length(diags)
    M <- 1000
    boot_out <- matrix(NA, nrow = M, ncol = N)
    
    set.seed(17)
    for (i in 1:M){
        x <- sort(runif(N, 0, max(diags)))
        the_smo <- smooth.spline(x, 1:N, df=4)
        boot_out[i, ] <- (1:N) - predict(the_smo, x)$y
    }
    
    plot(NA, xlim=c(0,max(diags)), ylim=c(-0.8*max(boot_out),0.8*max(boot_out)), xlab="days", ylab="deviation from smooth")
    sapply(seq(1000),
           function(i) lines(x, boot_out[i,], col="grey")) 
    
    lines(diags, cum_inc - predict(smo, diags)$y, col="red")
    lines(x, apply(boot_out, 2, quantile, probs=0.975), col="blue")
    lines(x, apply(boot_out, 2, quantile, probs=0.025), col="blue")
    
}



#' Estimate smoothed incidence functions and inspect deviations in the registry data.
#' 
#' The second plot shows the deviation of the raw data from
#' the fitted smooth by day.
#'
#' The third plot shows the incidence rate per year of the registry, plotted in red. Mean
#' incidence rate is shown as a dashed black line, with the 95\% confidence interval shown with
#' dashed blue lines. A smooth fitted to the incidence data is shown in green. In the final
#' plot, the red line is the deviation of cumulative diagnoses from the fitted smooth (the same
#' as the black line in plot 2). In order to ascertain if the deviation is within reasonable
#' bounds, simulation is used. The grey lines represent N draws from a uniform distribution
#' between 0 and the last day of diagnosis, where N is the number of incident cases, plotted
#' as deviations from the smooth of cumulative diagnoses. The blue lines are 95\% confidence
#' intervals drawn from the simulated data.
#'
#' @param entry Vector of diagnosis dates for each patient in the registry.
#' @param start Date from which incident cases are included.
#' @param num_years Integer representing the number of complete years of the registry for which incidence is to be calculated.
#' @param N Number of draws from a homogeneous Poisson process.
#' @param df Degrees of freedom for the smoothening function.
#' @return Plots of the smoothed incidence function and corresponding deviations.
#' @examples
#' smoothed_incidence(registry_data$entrydate, start = "2004-01-30", num_years = 9)
smoothed_incidence <- function(entry, start = NULL, num_years = NULL, N=1000, df=6){

  if (is.null(start))
      start <- min(entry)
    
  if (is.null(num_years)) 
      num_years <- floor(as.numeric(difftime(max(entry), start) / 365.25))
    
  raw_incidence <- incidence(entry, start, num_years)

  # Slightly confused that the following are not all integers:
  diags <- sort(as.numeric(difftime(entry, min(entry), units='days')))
  cum_inc <- seq(length(diags))
  smo <- smooth.spline(diags, cum_inc, df=df)

  par(mfrow=c(2,2))
  
  plot(diags, cum_inc, pch=20, cex=0.7, xlab="days", ylab="cumulative diagnoses")
  abline(a=0, b=length(diags)/diags[length(diags)], col="red", lwd=2)
  lines(smo, col="green", lwd=2)

  plot(diags, cum_inc - predict(smo, diags)$y, type="l", xlab="days", ylab="deviation from smooth")
  mean_rate <- mean(raw_incidence)
  day_mean_rate <- mean_rate/365
  CI_lim <- 1.96 * sqrt(mean_rate)/365
  pl_lim <- CI_lim * 2.0

  plot(365*(1:num_years) - 182.5, raw_incidence/365, pch=20, col="red",
       xlab="days", ylab="incidence rate",
       ylim=c(day_mean_rate-pl_lim, day_mean_rate+pl_lim ))
  lines(365*(1:num_years) - 182.5, raw_incidence/365, col="red",lwd=2)
  lines(predict(smo, 1:(365*num_years), deriv=1), type="l", lwd=2, col="green")

  abline(h = day_mean_rate, lty=2)
  abline(h = day_mean_rate - CI_lim, lty=3, col="blue")
  abline(h = day_mean_rate + CI_lim, lty=3, col="blue")
  abline(v=(1:num_years)*365, col="pink", lty=2)

  N <- length(diags)
  M <- 1000
  boot_out <- matrix(NA, nrow = M, ncol = N)

  set.seed(17)
  for (i in 1:M){
    x <- sort(runif(N, 0, max(diags)))
    the_smo <- smooth.spline(x, 1:N, df=4)
    boot_out[i, ] <- (1:N) - predict(the_smo, x)$y
  }
  
  plot(NA, xlim=c(0,max(diags)), ylim=c(-0.8*max(boot_out),0.8*max(boot_out)), xlab="days", ylab="deviation from smooth")
  sapply(seq(1000),
         function(i) lines(x, boot_out[i,], col="grey")) 

  lines(diags, cum_inc - predict(smo, diags)$y, col="red")
  lines(x, apply(boot_out, 2, quantile, probs=0.975), col="blue")
  lines(x, apply(boot_out, 2, quantile, probs=0.025), col="blue")

}

#' Plot the age distribution of incident cases in the registry data.
#'
#' @param agedata Vector of age at diagnosis for each patient in the registry.
#' @param df Degrees of freedom for the smooth.
#' @return Plot of the raw data and smoothed age distribution function.
#' @examples
#' incidence_age_distribution(registry_data_r$age)
incidence_age_distribution <- function(agedata, df=10){
  
  ages <- vapply(seq(100), function(i) sum(floor(agedata) + 1 == i), numeric(1))
  
  plot(0:99, ages[1:100], pch=20, xlab="age (years)", ylab="incident cases")
  smage <- smooth.spline(0:99, ages[1:100], df=df)
  lines(smage, col="blue", lwd=2)

}

#' Inspect consistency of survival data between years of the registry and with a Cox Proportional Hazards model.
#'
#' The first plot is of the Kaplan-Meier survival curve on total cases in the registry. The second plot is the
#' Kaplan-Meier survival curve for each age group, as delineated by the user using the "ages" argument. The third
#' plot is of the residuals between the raw data and the fitted Cox Proportional Hazards model. If the model is
#' a good representation of the data the line should be horizontal. The last plot is of Kaplain Meier survival
#' curves fitted to cases subdivided by year of diagnosis within the registry (black lines), compared to total
#' cases shown in blue.
#'
#' @param form
#' @param data A registry dataset of patient cases generated using load_data().
#' @param ages A vector of ages at which to break the dataset for Kaplan Meier plotting.
#' @param start Date from which incident cases are included.
#' @param num_years Integer representing the number of complete years of the registry for which incidence is to be calculated.
#' @return A sequence of plots indicated the consistency of survival data between years of the registry and with a Cox Proportional Hazards model.
#' @examples
#' survival_modelling_diagnostics(Surv(time, status) ~ age(age) + entry(entrydate), registry_data,
#' ages = c(55, 65, 75, 85, 100), start = "2004-09-01", num_years = 9)
survival_modelling_diagnostics <- function(form, data, ages, start = NULL, num_years = NULL){
    
    ### TO DO/discuss:
    # ?Too much duplicated code with prevalence() to extract variables from formula
    # Make generic to not just age cuts
    
    # Extract required column names from formula
    spec <- c('age', 'entry')
    terms <- terms(form, spec)
    special_indices <- attr(terms, 'specials')
    
    if (any(sapply(special_indices, is.null)))
        stop("Error: Provide function terms for age and entry date.")
    
    v <- as.list(attr(terms, 'variables'))[-1]
    var_names <- unlist(lapply(special_indices, function(i) v[i]))
    
    age_var <- .extract_var_name(var_names$age)
    entry_var <- .extract_var_name(var_names$entry)
    
    # Extract survival formula
    response_index <- attr(terms, 'response')
    resp <- v[response_index][[1]]
    non_covariate_inds <- c(response_index, unlist(special_indices))
    covar_names <- as.list(attr(terms, 'variables'))[-1][-non_covariate_inds]  # First -1 to remove 'list' entry
    
    if (length(covar_names) > 0)
        stop("Error: Functionality isn't currently provided for additional covariates.")
    
    # Determine the registry years of interest from assessing the code
    if (is.null(start))
        start <- min(data[, entry_var])
    
    if (is.null(num_years)) 
        num_years <- floor(as.numeric(difftime(max(data[, entry_var]), start) / 365.25))
    
    # Check ages input is correct
    if (is.numeric(ages) != TRUE) stop("Error: ages is not numeric.")
    if (is.vector(ages) != TRUE) stop("Error: ages is not a vector.")
    
    par(mfrow=c(2,2))
    
    # Plot KM overall
    data_r <- data[data[, entry_var] >= start, ]
    surv_form_1 <- as.formula(paste(deparse(resp), '~ 1'))
    km <- survfit(surv_form_1, data_r)
    plot(km, lwd=2, col="blue", xlab="survival (days)", ylab="probability")
    
    # Plot KM stratified by age
    plot(survfit(as.formula(paste(deparse(resp), '~ cut(', 
                                          age_var, ', breaks = ages)', sep='')), data_r), 
                 lwd=2, col=1:length(ages), xlab="survival (days)", ylab="probability")
    cx <- coxph(as.formula(paste(deparse(resp), '~ ', age_var, sep='')), data_r)
    cxp <- survfit(cx, 
                   newdata=data.frame(assign(age_var, 
                                             vapply(seq(length(ages) - 1), 
                                                    function(i) mean(c(ages[i], ages[i + 1])), 
                                                    numeric(1)))))
    lines(cxp, lwd=2, col=1:length(ages), lty=2, mark.time=F)
    
    # Plot coxph residuals
    plot(cox.zph(cx))
    
    # Plot KM stratified by year of diagnosis
    plot(km, lwd=2, col="blue", mark.time=F, conf.int=T, xlab="survival (days)", ylab="probability")
    registry_years <- .determine_registry_years(start, num_years)
    sapply(seq(num_years),
           function(i) lines(survfit(surv_form_1, 
                                     data=data[data[, entry_var] >= registry_years[i] & data[, entry_var] < registry_years[i + 1], ]), 
                             mark.time = F, conf.int = F)) 
    
    sapply(seq(num_years),
           function(i) length(data$entrydate[data[, entry_var] >= registry_years[i] & data[, entry_var] < registry_years[i + 1]]))
    
    # Output plots and test of proportionality assumption
    return(cox.zph(cx))
    
}

#' Inspect functional form of age.
#'
#' @param form 
#' @param data A registry dataset of patient cases.
#' @param df Degrees of freedom for the smooth.
#' @return Plots of the functional form of age.
#' @examples
#' functional_form_age(registry_data_r)
functional_form_age <- function(form, data, df=4){
  
  ### TO DO/discuss:
  # ?No reason why this can't be applied to any continuous covariate, just need to change age() and age_ prefixes
  # ?How to neaten up the output; control side effects, do we need both plots etc
  # ?Too much duplication of code here with prevalence()
  ###
    
  # Extract required column names from formula
  terms <- terms(form, 'age')
  special_indices <- attr(terms, 'specials')
    
  if (any(sapply(special_indices, is.null)))
    stop("Error: Provide function term for age.")
    
  v <- as.list(attr(terms, 'variables'))[-1]
  var_names <- unlist(lapply(special_indices, function(i) v[i]))
  age_var <- .extract_var_name(var_names$age)
    
  # Extract survival formula
  response_index <- attr(terms, 'response')
  resp <- v[response_index][[1]]
  
  psp_surv_form <- as.formula(paste(deparse(resp), '~ pspline(', 
                                    age_var, ', ', df, ')', sep=''))
  
  cxnl <- coxph(psp_surv_form, data)
  output1 <- summary(cxnl)

  plt1 <- termplot(cxnl)

  f <<- datadist(data)
  options(datadist="f")

  rcs_surv_form <- as.formula(paste(deparse(resp), '~ rcs(', 
                                    age_var, ', ', df, ')', sep=''))
  
  mod_rms <- cph(rcs_surv_form, data, x=TRUE, y=TRUE, surv=T, time.inc=1)
  output2 <- anova(mod_rms)
  output3 <- summary(mod_rms)
  
  plt2 <- plot(eval(parse(text=paste('Predict(mod_rms, ', age_var,')', sep = ''))), lwd=3, adj.subtitle=T)

  list(plt1, plt2, output1, output2, output3)

}