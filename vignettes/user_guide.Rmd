---
title: "rprev User Guide"
author: "S J Lax and S E Lacy"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: bibliography.bib
vignette: >
  %\VignetteIndexEntry{rprev User Guide}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

# Introduction

In this vignette we demonstrate how to use `rprev` to generate predictions of disease prevalence from a registry data set. Prevalence is defined as the number of people living with a disease at a specified *index date* who were incident in the preceeding *n* years. Therefore, the higher the value of *n*, the more incident cases are included. If *n* is less than or equal to the number of registry years, then the prevalence estimate is made by simply counting those remaining in the prevalent pool at the index date. Frequently, disease registries do not contain sufficient longitudinal information to accurately measure disease prevalence, and the desired *n* is greater than the number of registry years for which we have real patient data

Following the methodology of @crouch2014determining, which has been employed in published work [@roman2016myeloid, @smith2015lymphoma], prevalence contributions from patients incident prior to the registry beginning are estimated using Monte Carlo Simulation. This is illustrated in the diagram below:

<div style="text-align:center" markdown="1">

![Estimating prevalence from registry data using rprev.](diagram.png)

</div>

Modelling prevalence therefore involves two stochastic processes: incidence, and survival. `rprev` provides an object-oriented way of specifying each of these two processes, along with appropriate user-friendly defaults that work well in general situations. In the following sections we aim to provide a reference manual for using `rprev` to generate accurate estimates of disease prevalence. Using the default models is covered, followed by a guide on providing custom incidence and survival objects for fine-grained control. It is important that both of these processes are accurately modelled to generate reliable prevalence estimates; the [Diagnostics vignette](diagnostics.html) goes into depth on evaluating the assumptions behind the default models.


# Simulated data

```{r setup, message = FALSE, warning = FALSE}
library(rprev)
library(survival)
data(prevsim)
```

`rprev` provides a simulated data set for testing purposes, called *prevsim*. It has been synthesised to resemble disease registry data. Incident cases are recorded from 2003-01-01 to 2013-01-30, and events occur between `r min(prevsim$eventdate)` and `r max(prevsim$eventdate)`. It has 6 columns and is organised in a fashion typical to that found in real registry data sets. Patient data includes the date of both entry into the registry and last follow-up, survival time (*time*) and a death indicator (*status*) along with both age and sex. 

```{r}
summary(prevsim)
```

The following Kaplan-Meier plot shows that survival in *prevsim* is typical of many diseases, whereby males have poorer survival outcomes than females. It also highlights that survival starts to level off after 2000 days.

```{r, echo=F}
#As our registry is short relative to the duration of survival from this disease, we do not have much information about long-term survival after this point in our patient population in order to base a model. In this scenario, instead of extrapolating survival (and thus risking the problem of "immortal" subjects), we recommend using general population survival data to model long-term survivors, and we refer to this as a *cure model* [@crouch2014determining]. In this model, after a specified "cure time", surviving subjects are considered to revert to the survival characteristics for someone of their age and sex in the general population. In our example, a patient is considered *cured* after five years survival with the disease.

#Until the point in time that the cure model takes effect, survival is modelled on disease registry data; after this time, survival probability for the surviving cases is modelled using population mortality rates. `rprev` includes data from the Office of National Statistics (ONS) [see @ons, data licenced under the Open Government Licence v3.0] to describe UK mortality rates (in data set `UKmortality`), however, the user may supply their own population mortality data. 
```

```{r basicsurvival, fig.height=4, fig.width=7, echo=F}
survf <- survfit(Surv(time, status) ~ sex, data=prevsim)
survf_df <- data.frame(t=survf$time, s=survf$surv, sex=rep(c('M', 'F'), survf$strata))
ggplot2::ggplot(survf_df, ggplot2::aes(x=t, y=s, colour=sex)) +
    ggplot2::geom_line() +
    ggplot2::theme_bw() +
    ggplot2::labs(x='Time (days)', y='Survival probability') +
    ggplot2::ylim(0, 1)
```

# Prevalence estimation

The primary function in `rprev` is `prevalence`, which performs all the data pre-processing and simulation required for estimating prevalence at an index date, given registry data and the specification of the incidence and survival processes. The function is designed to be flexible and modular, it does not make any assumptions on the nature of the two processes but only requires that they have specified behaviours (described later). We have provided default incidence and survival models with the package that are flexible enough to cover the majority of data sets. This section details how to get up-and-running using these default models to obtain prevalence estimations.

## Incidence specification

The default incidence model assumes a Poisson homogeneous process, i.e. that the incidence rate is constant. This may not necessarily be the case for some diseases, but the assumption generally holds. Of course, it is important to check whether your data meets this assumption; diagnostics are covered in [a separate vignette](diagnostics.html). A Poisson homogeneous process relies on a single parameter, the incidence rate. In `rprev` this is calculated within the `prevalence` function from incidence dates into the registry. An additional functionality that `rprev` provides is allowing for stratification of incidence by a categorical variable, for example, sex.

The homogeneous Poisson process model is specified by an argument to `prevalence` called `inc_formula`, which accepts a formula with the LHS as name of the column that holds the incident dates, and the RHS naming the variables to stratify by (or 1 if none). For example, in the `prevsim` data set, the *entrydate* column describes the date the patient was entered into the registry, and so the formula for a non-stratified incidence model is `inc_formula = entrydate ~ 1`. If we have reason to believe that males and females have significantly different incidence rates then we can stratify by sex: `inc_formula = entrydate ~ sex`.

## Survival specification

The default survival model assumes that event times follow a standard parametric distribution. The default implementation in `rprev` is an optimised interface to the well-known `survival::survreg` function. There are two arguments to `prevalence` that control the default survival model, `surv_formula` and `dist`. `surv_formula` is a formula formatted in the same way as the argument to `survival::survreg`, i.e. where the LHS is a `Surv` object specifying survival time and event indicators, and the RHS details any covariates to include. For example, using the `prevsim` data set, `surv_formula = Surv(time, status) ~ age + sex`. The `dist` argument accepts a string specifying the distribution to use. Currently, it accepts the following values: *weibull*, *lognormal*, and *exponential* for the optimised implementation. If other distributions are required then a `flexsurv` object can be used, see below for details.

## Estimating prevalence

The function call for estimating prevalence in the `prevsim` data set using the default incidence and survival models is shown below. Aside from the arguments specifying these two processes, there are a number of prevalence-specific parameters. `index_date` specifies the date at which to estimate point prevalence with `num_years_to_estimate` detailing the required number of years preceding the index date that contribute incident cases. If any values are larger than the number of available complete years of registry data then incident cases over the remaining time are simulated. By passing a vector to `num_years_to_estimate`, multiple estimates of prevalence at the index date can be calculated with their own confidence intervals. `death_column` is required to count prevalence over the years of the registry, if it isn't provided then the entire prevalence estimate is calculated by simulation. The optional `population_size` argument is used to provide relative rates estimates. 

```{r}
prevalence_total <- prevalence(index='2013-01-30', 
                               num_years_to_estimate=c(3, 5, 10, 20), 
                               data=prevsim, 
                               inc_formula = entrydate ~ sex,
                               surv_formula = Surv(time, status) ~ age + sex, 
                               dist='weibull', 
                               population_size = 1e6,
                               death_column = 'eventdate')
```

Printing the returned `prevalence` object displays the point estimates of prevalence at the index date using the specified years of data, increasing with *n*:

```{r}
prevalence_total
```

More detail from the `prevalence` object can be extracted using `summary`, including the p-value from a hypothesis test (Poisson) of the difference between the predicted and counted prevalence for the available years of registry data. 

```{r}
summary(prevalence_total)
``` 

The prevalence object's `estimates` attribute holds the point prevalence estimate along with relative rates and confidence intervals.

```{r}
prevalence_total$estimates
```

## Using `flexsurv` objects

The default survival models are based on the `survival::survreg` function and are optimised to improve runtime. A more flexible alternative is to provide `flexsurv` objects from the `flexsurv` package. This is an easily extensible framework that comes with implementations of a large number of standard parametric families in addition to other models such as Royston and Parmar's Flexible Parametric Models. 

To use a `flexsurv` object with `prevalence`, simply fit one first and then pass it in through the `surv_model` argument. For example, the log-logistic distribution isn't currently supported by the default survival model in `rprev`, but it can be used in the `flexsurv` implementation. Firstly the survival model is fitted, allowing for appropriate diagnostics to be performed first.

```{r}
llog <- flexsurv::flexsurvreg(Surv(time, status) ~ age + sex, data=prevsim, dist='llogis')
llog
```

Now, the `surv_model` argument is used to pass in the survival model directly, rather than specifying `surv_formula` and `dist` as before. It must be emphasized that the runtime significantly increases when using a `flexsurv` object as they have not been optimised for use in `rprev`, however, they provide greater flexibility in the survival modelling. For example, the user can compare different survival models in the familiar `flexsurv` framework before using the final object in estimating prevalence.

```{r, cache=T}
prev_llog <- prevalence(index='2013-01-30', 
                        num_years_to_estimate=c(3, 5, 10, 20), 
                        data=prevsim, 
                        inc_formula = entrydate ~ sex,
                        surv_model=llog,
                        population_size = 1e6,
                        death_column = 'eventdate')
```

As can be seen, the prevalence estimates from different survival distributions can vary largely so it is important to use as accurate a model as possible. The [diagnostics vignette](diagnostics.html) discusses strategies on how to identify well-fitting models.

```{r}
prev_llog
```

# Custom incidence and survival models

The object-oriented manner in which the `prevalence` function is designed allows for custom survival and incidence objects to be used rather than relying on the default implementations. The previous section described both how to use the default models and also how to provide `flexsurv` survival objects. The latter works because the appropriate interface for `flexsurv` has been supplied with `rprev`, but the same mechanism can be used to provide custom objects. This section describes how to specify custom objects for both the incidence and survival models.

Both of these objects have similar requirements and are used in two ways during the simulation. During each iteration, new incidence and survival models are fitted to the bootstrapped registry data, generating new parameters. Based on these parameters, each model is then used for its primary purpose, either generating an incident population or predicting the survival of this population.

The way in which the models are fitted to the bootstrapped data is the same, the objects must contain a `call` object that holds the initial function call used to build the model. This call must contain an argument (name not important) which is passed the value `data`, as it is this argument which is changed to provide the bootstrapped data during simulation.

For example:

```{r, eval=F}
build_my_survival_object <- function(formula, input_data) {
    # Build a survival model using the specified formula and input data
    model <- ...
    object <- list(model=model,
                   call=match.call())  # the function call must be included as an item 'call'
    class(object) <- "myobj"
    object
}
```

It is **crucial** that the parameter passing in the data to fit the model to is labelled *data*, as below.

```{r, eval=F}
data <- data.frame(...)
myobj <- build_my_survival_object(Surv(time, status) ~ sex, data)
prevalence(...
           surv_model=myobj, # This will work
           ...)
```

The example below will **not** work.

```{r, eval=F}
some_data <- data.frame(...)
myobj <- build_my_survival_object(Surv(time, status) ~ sex, some_data)
prevalence(...
           surv_model=myobj, # This WON'T work, since the data parameter was called 'some_data' instead
           ...)
```

The second application of the models is to run their primary function, which is achieved by specifying an appropriate S3 class method. The following sections describes these methods and their parameterisation. See [Hadley Wickham's guide to S3 objects](http://adv-r.had.co.nz/S3.html) for further support on object-oriented programming in R.

## Incidence

It is likely that a homogeneous Poisson process is sufficient for the vast majority of diseases, although if greater control is required then a custom incidence model can be provided. Incidence models are characterised by the time-points at which new incident cases arise in the population. 

To this end, an incidence object needs to have an appropriate S3 class method called `draw_incident_population` that will generate the incident population in terms of their incident times and any covariates that are required for the survival modelling. The incident times are relative to the origin, which in the simulation is the index minus N years, where N is `max(num_years_to_estimate)`. The code snippet below describes the required parameterisation of `draw_incident_population`. 

**NB: in this and the following section, `myobj` is used as an example class name. This can be whatever you want provided it does not clash with the existing namespace**:

```{r, eval=F}
draw_incident_population.myobj <- function(object, data, timeframe, covars, ...) {
    # object: The incidence model that will have been created on the bootstrapped data
    # data: The data available to fit the model on, will be a bootstrapped subset of the 'data' argument to 'prevalence'
    # timeframe: A single number specifying how long to generate incident cases for.
    # covars: A character vector specifying the names of individual covariates that must be included in the returned data.table (or data frame)
    
    # Returns a data.table (or data frame but data.table is preferred) where each row represents an incident case with:
    #   - The first column being the time since the origin, i.e. index date - N year prevalence
    #   - Any subsequent columns holding covariates that must be provided as specified in the 'covars' argument
}
```

## Survival

Survival models are used in `prevalence` to estimate the probability that a person is alive at the index date. They require two methods to aid in this.

The first, `extract_covars` simply returns a character string detailing which of the covariates passed into `prevalence` through the `data` argument are used in the survival model. This allows the simulation to know how to generate the incident population as described above in `draw_incident_population`. In fact, the output of `extract_covars` is passed directly into `draw_incident_population` through the `covars` parameter.

```{r, eval=F}
extract_covars.myobj <- function(object) {
    # object: The survival model
    
    # Returns a character vector detailing the covariates required to fit this model. All of 
    # these values should be columns in the data that is passed in the main 'prevalence' function.
}
```

The second method of a survival object deals with predicting survival probability at the index date for the incident population. It is specified as follows:

```{r, eval=F}
predict_survival_probability.myobj <- function(object, newdata, times) {
    # object: The survival object
    # newdata: A data frame (or data.table) with the incident population stored with their 
    #   required covariates for the model.
    # times: A vector of times to estimate survival probability at for individuals in 
    #   corresponding rows of 'newdata'. This should be the same length as there are 
    #   rows in 'newdata' since each individual has their survival probability estimated once.
    
    # Returns:
    #  A vector of survival probabilities of length equal to the length of 'times' and the 
    #  number of rows in 'newdata'.
}
```

TODO Mention that object$simulated is entire incident population!

## Example

A concrete example highlighting the process of building a model with an appropriate `call` attribute and the required methods will be coming in a future release.

# References
